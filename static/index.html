<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PaperCut</title>
<link rel="icon" type="image/png" href="/static/favicon.png">
<link rel="apple-touch-icon" href="/static/icon.png">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Courier+Prime:ital,wght@0,400;0,700;1,400&family=DM+Sans:ital,wght@0,300;0,400;0,500;0,600;0,700;1,400&family=JetBrains+Mono:wght@300;400;500&display=swap" rel="stylesheet">
<style>
:root {
  --blue: #48A8DD;
  --blue-light: #e8f4fb;
  --blue-pale: #f2f9fd;
  --green: #61B87B;
  --green-light: #eaf6ee;
  --sunray: #EDAE49;
  --sunray-light: #fdf5e6;
  --brick: #D1495B;
  --brick-light: #fbeaec;
  --indigo: #003D5B;
  --ink: #011627;
  --bg: #FDFFFC;
  --bg-page: #F7F8F5;
  --bg-surface: #FFFFFF;
  --border: #E2E4DE;
  --border-light: #EEEFE9;
  --text: #1A1F2B;
  --text-secondary: #5A6275;
  --text-dim: #8E94A4;
  --font-display: 'DM Sans', system-ui, sans-serif;
  --font-script: 'Courier Prime', 'Courier New', Courier, monospace;
  --font-mono: 'JetBrains Mono', 'SF Mono', monospace;
  --radius: 8px;
  --radius-lg: 12px;
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.06);
  --shadow-md: 0 4px 12px rgba(0,0,0,0.08);
  --shadow-lg: 0 8px 30px rgba(0,0,0,0.10);
}

[data-theme="dark"] {
  --blue: #5BB8E8;
  --blue-light: #1a2e3d;
  --blue-pale: #141f2b;
  --green: #6FC88B;
  --green-light: #1a2d1f;
  --sunray: #F0BC5E;
  --sunray-light: #2b2415;
  --brick: #E05A6C;
  --brick-light: #2d1a1e;
  --indigo: #a8c8dc;
  --ink: #0d1117;
  --bg: #161b22;
  --bg-page: #0d1117;
  --bg-surface: #161b22;
  --border: #30363d;
  --border-light: #21262d;
  --text: #e6edf3;
  --text-secondary: #8b949e;
  --text-dim: #6e7681;
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.3);
  --shadow-md: 0 4px 12px rgba(0,0,0,0.4);
  --shadow-lg: 0 8px 30px rgba(0,0,0,0.5);
}

* { box-sizing: border-box; margin: 0; padding: 0; }

body {
  font-family: var(--font-display);
  background: var(--bg-page);
  color: var(--text);
  min-height: 100vh;
  -webkit-font-smoothing: antialiased;
}

.hidden { display: none !important; }

/* ── Layout ── */
.container {
  max-width: 960px;
  margin: 0 auto;
  padding: 0 24px;
}
.container-wide {
  max-width: 1400px;
  margin: 0 auto;
  padding: 0 24px;
}

/* ── Header ── */
header {
  background: var(--bg-surface);
  border-bottom: 1px solid var(--border);
  padding: 16px 0;
}
header .container-wide {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
header h1 {
  font-family: var(--font-display);
  font-size: 18px;
  font-weight: 600;
  color: var(--indigo);
}
header h1 span { color: var(--blue); }
#settingsToggle {
  background: none;
  border: 1px solid var(--border);
  color: var(--text-secondary);
  padding: 6px 14px;
  border-radius: 6px;
  cursor: pointer;
  font-family: var(--font-display);
  font-size: 13px;
  font-weight: 500;
  transition: all 0.15s;
}
#settingsToggle:hover {
  border-color: var(--blue);
  color: var(--blue);
}

/* ── Settings Overlay ── */
.settings-overlay {
  position: fixed;
  inset: 0;
  background: rgba(1, 22, 39, 0.4);
  z-index: 1000;
  display: flex;
  align-items: center;
  justify-content: center;
  animation: fadeIn 0.15s ease-out;
}
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}
.settings-panel {
  background: var(--bg-surface);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-lg);
  width: 580px;
  max-height: 85vh;
  overflow-y: auto;
  animation: slideUp 0.2s ease-out;
}
@keyframes slideUp {
  from { opacity: 0; transform: translateY(12px); }
  to { opacity: 1; transform: translateY(0); }
}
.settings-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 20px 24px;
  border-bottom: 1px solid var(--border-light);
}
.settings-header h2 {
  font-size: 16px;
  font-weight: 600;
  color: var(--indigo);
}
.settings-close {
  background: none;
  border: none;
  font-size: 20px;
  color: var(--text-dim);
  cursor: pointer;
  padding: 4px 8px;
  border-radius: 4px;
  line-height: 1;
}
.settings-close:hover { background: var(--bg-page); color: var(--text); }
.settings-body {
  padding: 24px;
}
.settings-section {
  margin-bottom: 24px;
}
.settings-section:last-child { margin-bottom: 0; }
.settings-section-title {
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  color: var(--text-dim);
  margin-bottom: 14px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border-light);
}
.settings-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 14px;
}
.settings-field {
  display: flex;
  flex-direction: column;
  gap: 5px;
}
.settings-field.full-width {
  grid-column: 1 / -1;
}
.settings-field label {
  font-size: 12px;
  font-weight: 500;
  color: var(--text-secondary);
}
.settings-field input,
.settings-field select {
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 8px 12px;
  font-family: var(--font-mono);
  font-size: 13px;
  color: var(--text);
  background: var(--bg-surface);
  transition: border-color 0.15s;
}
.settings-field input:focus,
.settings-field select:focus { outline: none; border-color: var(--blue); }
.settings-field .hint {
  font-size: 11px;
  color: var(--text-dim);
  line-height: 1.4;
}
.settings-footer {
  padding: 16px 24px;
  border-top: 1px solid var(--border-light);
  display: flex;
  justify-content: flex-end;
  gap: 10px;
}

/* ── Drop Zone ── */
.drop-zone-wrap {
  padding: 32px 0 24px;
}
.drop-zone {
  border: 2px dashed var(--border);
  border-radius: var(--radius-lg);
  padding: 48px 24px;
  text-align: center;
  transition: all 0.2s;
  cursor: pointer;
  background: var(--bg-surface);
}
.drop-zone.dragover {
  border-color: var(--blue);
  background: var(--blue-pale);
  box-shadow: 0 0 0 4px rgba(72, 168, 221, 0.1);
}
.drop-zone.uploading { pointer-events: none; opacity: 0.7; }
.drop-zone-icon {
  font-size: 36px;
  margin-bottom: 12px;
  color: var(--text-dim);
}
.drop-zone-text {
  font-size: 15px;
  color: var(--text-secondary);
  margin-bottom: 6px;
}
.drop-zone-text strong { color: var(--blue); }
.drop-zone-hint {
  font-size: 12px;
  color: var(--text-dim);
}
.drop-zone-file-input { display: none; }
.drop-alt {
  margin-top: 16px;
  display: flex;
  align-items: center;
  gap: 10px;
  justify-content: center;
}
.drop-alt-divider {
  font-size: 12px;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 1px;
}
.path-input {
  background: var(--bg-surface);
  border: 1px solid var(--border);
  color: var(--text);
  padding: 8px 14px;
  border-radius: 6px;
  font-family: var(--font-mono);
  font-size: 12px;
  width: 360px;
  transition: border-color 0.15s;
}
.path-input:focus { outline: none; border-color: var(--blue); }

/* ── Buttons ── */
.btn {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 8px 18px;
  border-radius: 6px;
  cursor: pointer;
  font-family: var(--font-display);
  font-weight: 500;
  font-size: 13px;
  border: none;
  transition: all 0.15s;
  white-space: nowrap;
}
.btn-primary {
  background: var(--blue);
  color: #fff;
}
.btn-primary:hover { background: #3a9ad0; }
.btn-primary:disabled { opacity: 0.4; cursor: not-allowed; }
.btn-secondary {
  background: var(--bg-surface);
  color: var(--text-secondary);
  border: 1px solid var(--border);
}
.btn-secondary:hover { border-color: var(--blue); color: var(--blue); }
.btn-danger-outline {
  background: none;
  color: var(--brick);
  border: 1px solid var(--brick-light);
}
.btn-danger-outline:hover {
  background: var(--brick-light);
  border-color: var(--brick);
}
.btn-success-outline {
  background: none;
  color: var(--green);
  border: 1px solid var(--green-light);
}
.btn-success-outline:hover {
  background: var(--green-light);
  border-color: var(--green);
}
.btn-sm { padding: 5px 12px; font-size: 12px; }

/* ── Progress Log ── */
#progress-section { padding: 0 0 24px; }
#progress-log {
  background: var(--ink);
  color: #b0bec5;
  border-radius: var(--radius);
  padding: 16px;
  font-family: var(--font-mono);
  font-size: 12px;
  max-height: 180px;
  overflow-y: auto;
  line-height: 1.7;
}
#progress-log .line { white-space: pre-wrap; word-break: break-all; }
#progress-log .line::before { content: "> "; color: #546e7a; }
#progress-log .line-error { color: var(--brick); }
#progress-log .line-error::before { content: "! "; color: var(--brick); }
#progress-log .line-done { color: var(--green); }
#progress-log .line-done::before { content: "\2713 "; color: var(--green); }

/* ── Video Section ── */
#video-section { padding-bottom: 0; }
.video-wrap {
  background: #000;
  border-radius: var(--radius-lg);
  overflow: hidden;
  box-shadow: var(--shadow-lg);
}
video { width: 100%; display: block; max-height: 400px; }

.video-toolbar {
  display: flex;
  align-items: center;
  gap: 20px;
  padding: 10px 0 0;
}
.video-toolbar label {
  font-size: 12px;
  color: var(--text-dim);
  display: flex;
  align-items: center;
  gap: 5px;
  cursor: pointer;
}
.video-toolbar input[type="checkbox"] { accent-color: var(--blue); }

/* ── Stats Bar ── */
#summary-bar {
  display: flex;
  gap: 0;
  margin: 20px 0;
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  overflow: hidden;
  box-shadow: var(--shadow-sm);
}
.stat-card {
  flex: 1;
  padding: 14px 18px;
  text-align: center;
  border-right: 1px solid var(--border-light);
}
.stat-card:last-child { border-right: none; }
.stat-label {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1.2px;
  color: var(--text-dim);
  margin-bottom: 4px;
}
.stat-val {
  font-family: var(--font-mono);
  font-size: 20px;
  font-weight: 500;
  color: var(--indigo);
}
.stat-card.stat-danger .stat-val { color: var(--brick); }
.stat-card.stat-accent .stat-val { color: var(--blue); }

/* ── Transcript Two-Column ── */
#transcript-section { padding-bottom: 24px; }
.transcript-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}
.transcript-col-headers {
  display: flex;
  flex: 1;
  gap: 16px;
}
.transcript-col-label {
  flex: 1;
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  color: var(--text-dim);
}
.transcript-col-label.label-edit { text-align: left; }

.transcript-columns {
  display: flex;
  gap: 16px;
  align-items: stretch;
}

.script-page {
  flex: 1;
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  box-shadow: var(--shadow-sm);
  overflow: hidden;
  max-height: 55vh;
  overflow-y: auto;
}
.script-page.pane-original {
  border-left: 3px solid var(--border);
}
.script-page.pane-edit {
  border-left: 3px solid var(--blue);
}

/* Block cards */
.block-card {
  padding: 14px 20px;
  border-bottom: 1px solid var(--border-light);
  transition: background 0.15s;
  position: relative;
  animation: fadeSlideIn 0.3s ease-out both;
}
@keyframes fadeSlideIn {
  from { opacity: 0; transform: translateY(4px); }
  to { opacity: 1; transform: translateY(0); }
}
.block-card:last-child { border-bottom: none; }
.block-card:hover { background: var(--bg-page); }
.block-card.active {
  background: var(--blue-pale);
  box-shadow: inset 3px 0 0 var(--blue);
}

.block-meta {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 6px;
}
.block-meta-left {
  display: flex;
  align-items: center;
  gap: 10px;
}
.block-number {
  font-family: var(--font-mono);
  font-size: 11px;
  font-weight: 500;
  color: var(--text-dim);
  background: var(--bg-page);
  padding: 2px 8px;
  border-radius: 4px;
  min-width: 28px;
  text-align: center;
}
.block-time {
  font-family: var(--font-mono);
  font-size: 11px;
  color: var(--text-dim);
  cursor: pointer;
}
.block-time:hover { color: var(--blue); }
.block-actions {
  display: flex;
  align-items: center;
  gap: 6px;
  opacity: 0;
  transition: opacity 0.15s;
}
.block-card:hover .block-actions { opacity: 1; }

.block-text {
  font-family: var(--font-script);
  font-size: 14px;
  line-height: 1.65;
  color: var(--text);
  min-height: 1.65em;
  outline: none;
  padding: 2px 0;
  border-bottom: 1px solid transparent;
  transition: border-color 0.15s;
}
.block-text:focus {
  border-bottom-color: var(--blue);
}
.block-text[contenteditable="true"]::selection {
  background: var(--blue-light);
}

/* ── Cut blocks (edit pane) ── */
.pane-edit .block-card.is-cut {
  background: var(--brick-light);
  opacity: 0.7;
}
.pane-edit .block-card.is-cut .block-number { background: var(--brick-light); color: var(--brick); }
.pane-edit .block-card.is-cut .block-text {
  text-decoration: line-through;
  text-decoration-color: var(--brick);
  color: var(--text-dim);
  font-style: italic;
}
.pane-edit .block-card.is-cut .block-actions { opacity: 1; }

/* ── Cut blocks (original pane) ── */
.pane-original .block-card.is-cut {
  background: var(--brick-light);
}
.pane-original .block-card.is-cut .block-number { background: var(--brick-light); color: var(--brick); }
.pane-original .block-card.is-cut .block-text {
  text-decoration: line-through;
  text-decoration-color: var(--brick);
  color: var(--brick);
}

/* ── Word-level diff marks (original pane) ── */
.diff-del {
  color: var(--brick);
  background: var(--brick-light);
  text-decoration: line-through;
  text-decoration-color: var(--brick);
  border-radius: 2px;
  padding: 0 2px;
}
.diff-ok {
  /* default — no special styling */
}

/* ── Cut badge ── */
.cut-badge {
  font-family: var(--font-mono);
  font-size: 10px;
  font-weight: 500;
  color: var(--brick);
  background: var(--bg-surface);
  border: 1px solid var(--brick);
  padding: 2px 8px;
  border-radius: 4px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* ── Edited badge ── */
.edited-badge {
  font-family: var(--font-mono);
  font-size: 10px;
  font-weight: 500;
  color: var(--sunray);
  background: var(--sunray-light);
  border: 1px solid var(--sunray);
  padding: 2px 8px;
  border-radius: 4px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* ── Export Section ── */
#export-section {
  padding: 24px 0;
}
.export-bar {
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 16px 24px;
  display: flex;
  align-items: center;
  gap: 24px;
  flex-wrap: wrap;
  box-shadow: var(--shadow-sm);
}
.export-field {
  display: flex;
  align-items: center;
  gap: 8px;
}
.export-label {
  font-size: 12px;
  font-weight: 500;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.export-bar select,
.export-bar input[type="range"] {
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 13px;
  font-family: var(--font-display);
  padding: 6px 10px;
  background: var(--bg-surface);
  color: var(--text);
}
.export-bar input[type="range"] { width: 120px; accent-color: var(--blue); }
.range-val {
  font-family: var(--font-mono);
  font-size: 13px;
  color: var(--blue);
  min-width: 40px;
}
.export-spacer { flex: 1; }

/* ── Info Tooltip ── */
.info-tip {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--border);
  color: var(--text-dim);
  font-size: 10px;
  font-weight: 700;
  font-style: normal;
  font-family: var(--font-display);
  cursor: pointer;
  position: relative;
  margin-left: 4px;
  vertical-align: middle;
  flex-shrink: 0;
  transition: background 0.15s, color 0.15s;
}
.info-tip:hover {
  background: var(--blue);
  color: #fff;
}
.info-tip .tip-text {
  display: none;
  position: absolute;
  bottom: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
  background: var(--ink);
  color: #e0e0e0;
  font-size: 12px;
  font-weight: 400;
  line-height: 1.5;
  padding: 10px 14px;
  border-radius: 6px;
  width: 260px;
  white-space: normal;
  box-shadow: var(--shadow-lg);
  z-index: 100;
  pointer-events: none;
}
.info-tip .tip-text::after {
  content: "";
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  border: 6px solid transparent;
  border-top-color: var(--ink);
}
.info-tip:hover .tip-text,
.info-tip:focus .tip-text {
  display: block;
}

/* ── Advanced Panel ── */
#advanced-panel {
  padding-bottom: 24px;
}
.advanced-card {
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 20px 24px;
  box-shadow: var(--shadow-sm);
}
.advanced-title {
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  color: var(--text-dim);
  margin-bottom: 14px;
}
.advanced-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 14px;
}
.advanced-grid label {
  display: flex;
  flex-direction: column;
  gap: 5px;
  font-size: 12px;
  font-weight: 500;
  color: var(--text-secondary);
}
.advanced-grid input {
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 8px 12px;
  font-family: var(--font-mono);
  font-size: 13px;
  color: var(--text);
  background: var(--bg-surface);
  transition: border-color 0.15s;
}
.advanced-grid input:focus { outline: none; border-color: var(--blue); }

/* ── Export Result ── */
#export-result {
  margin-bottom: 24px;
  padding: 16px 20px;
  border-radius: var(--radius);
  font-family: var(--font-mono);
  font-size: 12px;
  white-space: pre-wrap;
  line-height: 1.6;
}
#export-result.success {
  background: var(--green-light);
  color: #2d6e3f;
  border: 1px solid var(--green);
}
#export-result.error {
  background: var(--brick-light);
  color: var(--brick);
  border: 1px solid var(--brick);
}

/* ── Scrollbar ── */
.script-page::-webkit-scrollbar { width: 6px; }
.script-page::-webkit-scrollbar-track { background: transparent; }
.script-page::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
.script-page::-webkit-scrollbar-thumb:hover { background: var(--text-dim); }

/* ── Stagger delays ── */
.script-page .block-card:nth-child(1) { animation-delay: 0.02s; }
.script-page .block-card:nth-child(2) { animation-delay: 0.04s; }
.script-page .block-card:nth-child(3) { animation-delay: 0.06s; }
.script-page .block-card:nth-child(4) { animation-delay: 0.08s; }
.script-page .block-card:nth-child(5) { animation-delay: 0.10s; }
.script-page .block-card:nth-child(6) { animation-delay: 0.12s; }
.script-page .block-card:nth-child(7) { animation-delay: 0.14s; }
.script-page .block-card:nth-child(8) { animation-delay: 0.16s; }
.script-page .block-card:nth-child(9) { animation-delay: 0.18s; }
.script-page .block-card:nth-child(n+10) { animation-delay: 0.20s; }

/* ── Theme Toggle ── */
.theme-toggle {
  background: none;
  border: 1px solid var(--border);
  color: var(--text-secondary);
  width: 34px;
  height: 34px;
  border-radius: 6px;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  transition: all 0.15s;
  line-height: 1;
}
.theme-toggle:hover {
  border-color: var(--blue);
  color: var(--blue);
}
.header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
}
</style>
</head>
<body>

<header>
  <div class="container-wide">
    <h1>Paper<span>Cut</span></h1>
    <div class="header-actions">
      <button class="theme-toggle" id="themeToggle" onclick="toggleTheme()" title="Toggle dark mode"></button>
      <button id="settingsToggle" onclick="toggleSettings()">Settings</button>
    </div>
  </div>
</header>

<!-- Settings Overlay -->
<div id="settingsOverlay" class="settings-overlay hidden" onclick="if(event.target===this)toggleSettings()">
  <div class="settings-panel">
    <div class="settings-header">
      <h2>Settings</h2>
      <button class="settings-close" onclick="toggleSettings()">&times;</button>
    </div>
    <div class="settings-body">

      <div class="settings-section">
        <div class="settings-section-title">Transcription</div>
        <div class="settings-grid">
          <div class="settings-field">
            <label>WhisperX model</label>
            <select id="settWhisperModel">
              <option value="tiny">tiny</option>
              <option value="base">base</option>
              <option value="small">small</option>
              <option value="medium" selected>medium</option>
              <option value="large-v2">large-v2</option>
              <option value="large-v3">large-v3</option>
            </select>
          </div>
          <div class="settings-field">
            <label>Language</label>
            <input type="text" id="settLanguage" value="en" placeholder="en">
            <span class="hint">ISO 639-1 code (en, es, fr, de, ja...)</span>
          </div>
        </div>
      </div>

      <div class="settings-section">
        <div class="settings-section-title">Export Defaults</div>
        <div class="settings-grid">
          <div class="settings-field">
            <label>Default format</label>
            <select id="settExportFormat">
              <option value="final-cut-pro">Final Cut Pro</option>
              <option value="premiere">Premiere</option>
              <option value="resolve">DaVinci Resolve</option>
              <option value="clip-sequence">Clip Sequence</option>
              <option value="video">Video</option>
            </select>
          </div>
          <div class="settings-field">
            <label>Default margin (sec)</label>
            <input type="number" id="settMargin" value="0.10" min="0" max="2" step="0.05">
          </div>
          <div class="settings-field">
            <label>Silent speed</label>
            <input type="text" id="settSilentSpeed" placeholder="99999 (cut)">
          </div>
          <div class="settings-field">
            <label>Sounded speed</label>
            <input type="text" id="settSoundedSpeed" placeholder="1">
          </div>
          <div class="settings-field">
            <label>Video codec</label>
            <input type="text" id="settVideoCodec" placeholder="auto">
          </div>
          <div class="settings-field">
            <label>Audio codec</label>
            <input type="text" id="settAudioCodec" placeholder="auto">
          </div>
          <div class="settings-field full-width">
            <label>FFmpeg args</label>
            <input type="text" id="settFfmpegArgs" placeholder="-crf 22 -preset veryfast">
          </div>
          <div class="settings-field full-width">
            <label>Edit method</label>
            <input type="text" id="settEditMethod" placeholder="audio:threshold=4%">
            <span class="hint">auto-editor --edit flag (e.g. audio:threshold=4%, motion:threshold=2%)</span>
          </div>
        </div>
      </div>

      <div class="settings-section">
        <div class="settings-section-title">Editor</div>
        <div class="settings-grid">
          <div class="settings-field">
            <label>Sync playback on load</label>
            <select id="settSyncPlayback">
              <option value="true" selected>On</option>
              <option value="false">Off</option>
            </select>
          </div>
          <div class="settings-field">
            <label>Sync scroll on load</label>
            <select id="settSyncScroll">
              <option value="true" selected>On</option>
              <option value="false">Off</option>
            </select>
          </div>
        </div>
      </div>

    </div>
    <div class="settings-footer">
      <button class="btn btn-secondary btn-sm" onclick="resetSettings()">Reset Defaults</button>
      <button class="btn btn-primary btn-sm" onclick="saveSettings()">Save</button>
    </div>
  </div>
</div>

<div class="container">

  <!-- Drop Zone -->
  <div class="drop-zone-wrap">
    <div class="drop-zone" id="dropZone">
      <div class="drop-zone-icon">&#127916;</div>
      <div class="drop-zone-text">Drop a video file here or <strong>click to browse</strong></div>
      <div class="drop-zone-hint">mp4, mov, mkv, avi, webm</div>
      <input type="file" class="drop-zone-file-input" id="fileInput" accept="video/*">
    </div>
    <div class="drop-alt">
      <span class="drop-alt-divider">or</span>
      <input type="text" class="path-input" id="videoPath" placeholder="paste a local path" spellcheck="false">
      <button class="btn btn-secondary btn-sm" id="loadExistingBtn" onclick="loadExisting()">Load Existing</button>
    </div>
  </div>

  <!-- Progress log -->
  <div class="hidden" id="progress-section">
    <div id="progress-log"></div>
  </div>

  <!-- Video player -->
  <div class="hidden" id="video-section">
    <div class="video-wrap">
      <video id="videoPlayer" controls preload="metadata"></video>
    </div>
    <div class="video-toolbar">
      <label><input type="checkbox" id="syncToggle" checked> Sync playback</label>
      <label><input type="checkbox" id="scrollSyncToggle" checked> Sync scroll</label>
    </div>
  </div>

  <!-- Stats bar -->
  <div id="summary-bar" class="hidden">
    <div class="stat-card">
      <div class="stat-label">Blocks</div>
      <div class="stat-val" id="sumTotal">0</div>
    </div>
    <div class="stat-card stat-danger">
      <div class="stat-label">Cut</div>
      <div class="stat-val" id="sumRemoved">0</div>
    </div>
    <div class="stat-card stat-accent">
      <div class="stat-label">Time Removed</div>
      <div class="stat-val" id="sumTimeCut">0.0s</div>
    </div>
    <div class="stat-card stat-accent">
      <div class="stat-label">Reduction</div>
      <div class="stat-val" id="sumReduction">0%</div>
    </div>
  </div>

</div><!-- /.container -->

<!-- Transcript uses wider container for two columns -->
<div class="container-wide">

  <div id="transcript-section" class="hidden">
    <div class="transcript-header">
      <div class="transcript-col-headers">
        <div class="transcript-col-label">Original</div>
        <div class="transcript-col-label label-edit">Edit</div>
      </div>
      <button class="btn btn-secondary btn-sm" id="undoBtn" onclick="undoLast()" disabled>Undo</button>
    </div>
    <div class="transcript-columns">
      <div class="script-page pane-original" id="originalPane"></div>
      <div class="script-page pane-edit" id="editPane"></div>
    </div>
  </div>

  <!-- Export controls -->
  <div class="hidden" id="export-section">
    <div class="export-bar">
      <div class="export-field">
        <span class="export-label">Margin</span>
        <input type="range" id="marginSlider" min="0" max="1" step="0.05" value="0.10">
        <span class="range-val" id="marginVal">0.10s</span>
      </div>
      <div class="export-field">
        <span class="export-label">Format</span>
        <select id="exportFormat">
          <option value="final-cut-pro">Final Cut Pro</option>
          <option value="premiere">Premiere</option>
          <option value="resolve">DaVinci Resolve</option>
          <option value="clip-sequence">Clip Sequence</option>
          <option value="video">Video</option>
        </select>
      </div>
      <div class="export-spacer"></div>
      <button class="btn btn-secondary btn-sm" id="advancedToggle" onclick="toggleAdvanced()">Advanced</button>
      <button class="btn btn-primary" id="exportBtn" onclick="startExport()">Export</button>
    </div>
  </div>

  <!-- Advanced panel -->
  <div id="advanced-panel" class="hidden">
    <div class="advanced-card">
      <div class="advanced-title">Advanced Options</div>
      <div class="advanced-grid">
        <label>Silent speed <span class="info-tip" tabindex="0">i<span class="tip-text">Playback speed for silent/cut sections. Use 99999 to fully remove them, or a number like 8 to speed them up instead.</span></span> <input type="text" id="silentSpeed" placeholder="99999 (cut)"></label>
        <label>Sounded speed <span class="info-tip" tabindex="0">i<span class="tip-text">Playback speed for sections with audio. Default is 1 (normal speed). Use 1.5 or 2 to speed up the entire sounded portion.</span></span> <input type="text" id="soundedSpeed" placeholder="1"></label>
        <label>Video codec <span class="info-tip" tabindex="0">i<span class="tip-text">Video codec for re-encoding. Common options: h264, h265/hevc, prores. Leave blank for auto-editor's default.</span></span> <input type="text" id="videoCodec" placeholder="auto"></label>
        <label>Audio codec <span class="info-tip" tabindex="0">i<span class="tip-text">Audio codec for re-encoding. Common options: aac, pcm_s16le, mp3. Leave blank for auto-editor's default.</span></span> <input type="text" id="audioCodec" placeholder="auto"></label>
        <label>FFmpeg args <span class="info-tip" tabindex="0">i<span class="tip-text">Extra FFmpeg arguments passed through to the encoder. Example: -crf 22 -preset veryfast for H.264 quality/speed tradeoff.</span></span> <input type="text" id="ffmpegArgs" placeholder="-crf 22 -preset veryfast"></label>
        <label>Edit method <span class="info-tip" tabindex="0">i<span class="tip-text">auto-editor's --edit flag. Controls what gets detected as silence. Examples: audio:threshold=4%, motion:threshold=2%, or combine with audio:or:motion.</span></span> <input type="text" id="editMethod" placeholder="audio:threshold=4%"></label>
      </div>
    </div>
  </div>

  <!-- Export result -->
  <div id="export-result" class="hidden"></div>

</div><!-- /.container-wide -->

<script>
// ── State ──
let blocks = [];       // {id, index, start, end, text, originalText, deleted}
let undoStack = [];    // [{type: 'cut'|'edit', id, prevText?}]
let videoPath = "";
let srtPath = "";
let origSrtPath = "";
let jsonPath = "";
let currentHighlight = -1;
let deletedRanges = [];
let scrollSyncing = false;

// ── DOM refs ──
const $dropZone = document.getElementById("dropZone");
const $fileInput = document.getElementById("fileInput");
const $videoPathInput = document.getElementById("videoPath");
const $progressSection = document.getElementById("progress-section");
const $progressLog = document.getElementById("progress-log");
const $videoSection = document.getElementById("video-section");
const $videoPlayer = document.getElementById("videoPlayer");
const $syncToggle = document.getElementById("syncToggle");
const $scrollSyncToggle = document.getElementById("scrollSyncToggle");
const $transcriptSection = document.getElementById("transcript-section");
const $originalPane = document.getElementById("originalPane");
const $editPane = document.getElementById("editPane");
const $exportSection = document.getElementById("export-section");
const $marginSlider = document.getElementById("marginSlider");
const $marginVal = document.getElementById("marginVal");
const $undoBtn = document.getElementById("undoBtn");
const $summaryBar = document.getElementById("summary-bar");
const $exportResult = document.getElementById("export-result");

// ── Utilities ──
let _debounceTimers = {};
function debounce(key, fn, ms = 250) {
  clearTimeout(_debounceTimers[key]);
  _debounceTimers[key] = setTimeout(fn, ms);
}

function fmt(sec) {
  const m = Math.floor(sec / 60);
  const s = (sec % 60).toFixed(1);
  return m > 0 ? `${m}:${s.padStart(4, '0')}` : `${s}s`;
}

function logLine(msg, cls = "") {
  const div = document.createElement("div");
  div.className = "line" + (cls ? ` line-${cls}` : "");
  div.textContent = msg;
  $progressLog.appendChild(div);
  $progressLog.scrollTop = $progressLog.scrollHeight;
}

function escHtml(s) {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

// ── Word-Level Diff ──
// Uses LCS to find which words from the original were deleted
function wordDiff(original, edited) {
  const a = original.split(/(\s+)/).filter(s => s.length > 0);
  const b = edited.split(/(\s+)/).filter(s => s.length > 0);

  // Extract just the words (non-whitespace) for comparison
  const aWords = a.filter(s => s.trim().length > 0);
  const bWords = b.filter(s => s.trim().length > 0);

  const m = aWords.length, n = bWords.length;

  // Build LCS table
  const dp = [];
  for (let i = 0; i <= m; i++) {
    dp[i] = new Array(n + 1).fill(0);
  }
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (aWords[i - 1] === bWords[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }

  // Backtrack to find which original words are kept vs deleted
  const result = []; // {word, deleted: bool}
  let i = m, j = n;
  while (i > 0 || j > 0) {
    if (i > 0 && j > 0 && aWords[i - 1] === bWords[j - 1]) {
      result.unshift({ word: aWords[i - 1], deleted: false });
      i--; j--;
    } else if (j > 0 && (i === 0 || dp[i][j - 1] >= dp[i - 1][j])) {
      // Word added in edited — skip (not shown on left)
      j--;
    } else {
      result.unshift({ word: aWords[i - 1], deleted: true });
      i--;
    }
  }
  return result;
}

function renderDiffHtml(original, edited) {
  if (original === edited) return escHtml(original);

  const diff = wordDiff(original, edited);
  return diff.map(({ word, deleted }) =>
    deleted
      ? `<span class="diff-del">${escHtml(word)}</span>`
      : escHtml(word)
  ).join(" ");
}

// ── Drag & Drop ──
$dropZone.addEventListener("click", () => $fileInput.click());
$fileInput.addEventListener("change", (e) => {
  if (e.target.files.length) uploadFile(e.target.files[0]);
});

$dropZone.addEventListener("dragover", (e) => {
  e.preventDefault();
  $dropZone.classList.add("dragover");
});
$dropZone.addEventListener("dragleave", () => {
  $dropZone.classList.remove("dragover");
});
$dropZone.addEventListener("drop", (e) => {
  e.preventDefault();
  $dropZone.classList.remove("dragover");
  const file = e.dataTransfer.files[0];
  if (file) uploadFile(file);
});

function uploadFile(file) {
  $dropZone.classList.add("uploading");
  $dropZone.querySelector(".drop-zone-text").textContent = `Uploading ${file.name}...`;

  const form = new FormData();
  form.append("file", file);

  fetch("/api/upload", { method: "POST", body: form })
    .then(r => {
      if (!r.ok) return r.text().then(t => { throw new Error(`Upload failed (${r.status}): ${t.slice(0, 100)}`); });
      return r.json();
    })
    .then(data => {
      if (data.error) throw new Error(data.error);
      videoPath = data.path;
      $videoPathInput.value = videoPath;
      $dropZone.querySelector(".drop-zone-text").innerHTML = `<strong>${data.filename}</strong> ready`;
      $dropZone.classList.remove("uploading");
      startTranscribe();
    })
    .catch(err => {
      $dropZone.querySelector(".drop-zone-text").textContent = "Upload failed: " + err.message;
      $dropZone.classList.remove("uploading");
    });
}

// ── Transcription ──
function startTranscribe() {
  const path = videoPath || $videoPathInput.value.trim();
  if (!path) return;
  videoPath = path;

  $progressSection.classList.remove("hidden");
  $progressLog.innerHTML = "";

  fetch("/api/transcribe", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      video_path: path,
      model: loadSettings().whisperModel,
      language: loadSettings().language,
    }),
  }).then(response => {
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buf = "";

    function read() {
      reader.read().then(({ done, value }) => {
        if (done) return;
        buf += decoder.decode(value, { stream: true });
        const lines = buf.split("\n");
        buf = lines.pop();
        for (const line of lines) {
          if (!line.startsWith("data: ")) continue;
          try {
            const evt = JSON.parse(line.slice(6));
            if (evt.type === "progress") logLine(evt.message);
            else if (evt.type === "start") logLine(evt.message);
            else if (evt.type === "error") logLine(evt.message, "error");
            else if (evt.type === "done") {
              logLine(evt.message, "done");
              srtPath = evt.srt_path;
              origSrtPath = evt.orig_srt_path;
              jsonPath = evt.json_path;
              loadTranscript();
            }
          } catch (_) {}
        }
        read();
      });
    }
    read();
  }).catch(err => {
    logLine("Request failed: " + err.message, "error");
  });
}

// ── Load Existing ──
function loadExisting() {
  const path = $videoPathInput.value.trim();
  if (!path) return;
  videoPath = path;

  const base = path.replace(/\.[^.]+$/, "");
  srtPath = base + ".srt";
  origSrtPath = base + ".srt.orig";
  jsonPath = base + ".json";
  loadTranscript();
}

// ── Load Transcript ──
function loadTranscript() {
  $videoPlayer.src = `/media?path=${encodeURIComponent(videoPath)}`;
  $videoSection.classList.remove("hidden");

  // Try .srt.orig first, then .srt
  fetch(`/api/srt?path=${encodeURIComponent(origSrtPath)}`)
    .then(r => {
      if (r.ok) return r.json();
      return fetch(`/api/srt?path=${encodeURIComponent(srtPath)}`).then(r2 => {
        if (r2.ok) return r2.json();
        return null; // No SRT found
      });
    })
    .then(data => {
      if (!data || data.error || !Array.isArray(data)) {
        // No transcript exists yet — offer to transcribe
        $progressSection.classList.remove("hidden");
        logLine("No transcript found. Starting transcription...", "");
        startTranscribe();
        return;
      }

      blocks = data.map((b, i) => ({
        id: i,
        index: b.index,
        start: b.start,
        end: b.end,
        text: b.text,
        originalText: b.text,
        deleted: false,
      }));
      undoStack = [];
      $undoBtn.disabled = true;
      renderTranscript();
      $transcriptSection.classList.remove("hidden");
      $exportSection.classList.remove("hidden");
      $summaryBar.classList.remove("hidden");
      updateSummary();
    })
    .catch(err => {
      $progressSection.classList.remove("hidden");
      logLine("Failed to load SRT: " + err.message, "error");
    });
}

// ── Render Both Panes ──
function renderTranscript() {
  renderOriginalPane();
  renderEditPane();
  bindEditPaneEvents();
  bindScrollSync();
}

function renderOriginalPane() {
  $originalPane.innerHTML = "";

  for (const b of blocks) {
    const card = document.createElement("div");
    card.className = "block-card" + (b.deleted ? " is-cut" : "");
    card.dataset.id = b.id;
    card.dataset.start = b.start;
    card.dataset.end = b.end;

    const isEdited = !b.deleted && b.text !== b.originalText;
    const badgeHtml = b.deleted
      ? `<span class="cut-badge">\u2702 CUT</span>`
      : (isEdited ? `<span class="edited-badge">\u270E Edited</span>` : "");

    const textHtml = b.deleted
      ? escHtml(b.originalText)
      : renderDiffHtml(b.originalText, b.text);

    card.innerHTML = `
      <div class="block-meta">
        <div class="block-meta-left">
          <span class="block-number">${b.index ?? b.id + 1}</span>
          <span class="block-time">${fmt(b.start)} \u2013 ${fmt(b.end)}</span>
          ${badgeHtml}
        </div>
      </div>
      <div class="block-text">${textHtml}</div>
    `;

    card.addEventListener("click", () => seekTo(b.start));
    $originalPane.appendChild(card);
  }
}

function renderEditPane() {
  $editPane.innerHTML = "";

  for (const b of blocks) {
    const card = document.createElement("div");
    card.className = "block-card" + (b.deleted ? " is-cut" : "");
    card.dataset.id = b.id;
    card.dataset.start = b.start;
    card.dataset.end = b.end;

    if (b.deleted) {
      card.innerHTML = `
        <div class="block-meta">
          <div class="block-meta-left">
            <span class="block-number">${b.index ?? b.id + 1}</span>
            <span class="block-time">${fmt(b.start)} \u2013 ${fmt(b.end)}</span>
            <span class="cut-badge">\u2702 CUT</span>
          </div>
          <div class="block-actions" style="opacity:1">
            <button class="btn btn-success-outline btn-sm" data-restore="${b.id}">Restore</button>
          </div>
        </div>
        <div class="block-text">${escHtml(b.originalText)}</div>
      `;
    } else {
      card.innerHTML = `
        <div class="block-meta">
          <div class="block-meta-left">
            <span class="block-number">${b.index ?? b.id + 1}</span>
            <span class="block-time" data-seek="${b.start}">${fmt(b.start)} \u2013 ${fmt(b.end)}</span>
          </div>
          <div class="block-actions">
            <button class="btn btn-danger-outline btn-sm" data-cut="${b.id}">Cut</button>
          </div>
        </div>
        <div class="block-text" contenteditable="true" data-block-id="${b.id}">${escHtml(b.text)}</div>
      `;
    }

    $editPane.appendChild(card);
  }
}

function bindTextEditing(el) {
  if (!el) return;
  const id = parseInt(el.dataset.blockId);

  // Track text at focus time for undo
  let textAtFocus = "";
  el.addEventListener("focus", () => {
    const b = blocks.find(x => x.id === id);
    if (b) textAtFocus = b.text;
  });

  // Live update on input (debounced)
  el.addEventListener("input", () => {
    const b = blocks.find(x => x.id === id);
    if (!b) return;
    b.text = el.textContent.trim();
    debounce("edit-" + id, () => {
      updateOriginalBlock(id);
      updateSummary();
    }, 150);
  });

  // Snapshot undo on blur
  el.addEventListener("blur", () => {
    const b = blocks.find(x => x.id === id);
    if (!b) return;
    b.text = el.textContent.trim();
    if (b.text !== textAtFocus) {
      undoStack.push({ type: "edit", id: b.id, prevText: textAtFocus });
      $undoBtn.disabled = false;
    }
    // Final sync (no debounce)
    updateOriginalBlock(id);
    updateSummary();
  });

  el.addEventListener("keydown", (e) => {
    if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); el.blur(); }
  });
}

function bindEditPaneEvents() {
  // Cut buttons
  $editPane.querySelectorAll("[data-cut]").forEach(btn => {
    btn.addEventListener("click", (e) => {
      e.stopPropagation();
      cutBlock(parseInt(btn.dataset.cut));
    });
  });

  // Restore buttons
  $editPane.querySelectorAll("[data-restore]").forEach(btn => {
    btn.addEventListener("click", (e) => {
      e.stopPropagation();
      restoreBlock(parseInt(btn.dataset.restore));
    });
  });

  // Seek on timestamp click
  $editPane.querySelectorAll("[data-seek]").forEach(el => {
    el.addEventListener("click", () => seekTo(parseFloat(el.dataset.seek)));
  });

  // Text editing — live sync to left on input, undo snapshot on blur
  $editPane.querySelectorAll('.block-text[contenteditable="true"]').forEach(el => {
    bindTextEditing(el);
  });

  // Click card to seek (but not on buttons or editable text)
  $editPane.querySelectorAll(".block-card").forEach(card => {
    card.addEventListener("click", (e) => {
      if (e.target.closest("button") || e.target.closest('[contenteditable="true"]')) return;
      seekTo(parseFloat(card.dataset.start));
    });
  });
}

// ── Update single block on original pane (after text edit) ──
function updateOriginalBlock(id) {
  const b = blocks.find(x => x.id === id);
  if (!b) return;

  const card = $originalPane.querySelector(`[data-id="${id}"]`);
  if (!card) return;

  const isEdited = !b.deleted && b.text !== b.originalText;
  const badgeHtml = b.deleted
    ? `<span class="cut-badge">\u2702 CUT</span>`
    : (isEdited ? `<span class="edited-badge">\u270E Edited</span>` : "");

  const textHtml = b.deleted
    ? escHtml(b.originalText)
    : renderDiffHtml(b.originalText, b.text);

  card.className = "block-card" + (b.deleted ? " is-cut" : "");
  card.innerHTML = `
    <div class="block-meta">
      <div class="block-meta-left">
        <span class="block-number">${b.index ?? b.id + 1}</span>
        <span class="block-time">${fmt(b.start)} \u2013 ${fmt(b.end)}</span>
        ${badgeHtml}
      </div>
    </div>
    <div class="block-text">${textHtml}</div>
  `;
  card.addEventListener("click", () => seekTo(b.start));
}

// ── Update single block on edit pane ──
function updateEditBlock(id) {
  const b = blocks.find(x => x.id === id);
  if (!b) return;

  const card = $editPane.querySelector(`[data-id="${id}"]`);
  if (!card) return;

  card.className = "block-card" + (b.deleted ? " is-cut" : "");

  if (b.deleted) {
    card.innerHTML = `
      <div class="block-meta">
        <div class="block-meta-left">
          <span class="block-number">${b.index ?? b.id + 1}</span>
          <span class="block-time">${fmt(b.start)} \u2013 ${fmt(b.end)}</span>
          <span class="cut-badge">\u2702 CUT</span>
        </div>
        <div class="block-actions" style="opacity:1">
          <button class="btn btn-success-outline btn-sm" data-restore="${b.id}">Restore</button>
        </div>
      </div>
      <div class="block-text">${escHtml(b.originalText)}</div>
    `;
    card.querySelector("[data-restore]").addEventListener("click", (e) => {
      e.stopPropagation();
      restoreBlock(b.id);
    });
  } else {
    card.innerHTML = `
      <div class="block-meta">
        <div class="block-meta-left">
          <span class="block-number">${b.index ?? b.id + 1}</span>
          <span class="block-time" data-seek="${b.start}">${fmt(b.start)} \u2013 ${fmt(b.end)}</span>
        </div>
        <div class="block-actions">
          <button class="btn btn-danger-outline btn-sm" data-cut="${b.id}">Cut</button>
        </div>
      </div>
      <div class="block-text" contenteditable="true" data-block-id="${b.id}">${escHtml(b.text)}</div>
    `;
    card.querySelector("[data-cut]").addEventListener("click", (e) => {
      e.stopPropagation();
      cutBlock(b.id);
    });
    card.querySelector("[data-seek]").addEventListener("click", () => seekTo(b.start));
    bindTextEditing(card.querySelector('[contenteditable="true"]'));
  }

  card.addEventListener("click", (e) => {
    if (e.target.closest("button") || e.target.closest('[contenteditable="true"]')) return;
    seekTo(parseFloat(card.dataset.start));
  });
}

// ── Scroll Sync ──
function bindScrollSync() {
  function syncScroll(source, target) {
    if (scrollSyncing) return;
    scrollSyncing = true;
    const pct = source.scrollTop / (source.scrollHeight - source.clientHeight || 1);
    target.scrollTop = pct * (target.scrollHeight - target.clientHeight);
    requestAnimationFrame(() => { scrollSyncing = false; });
  }

  $originalPane.addEventListener("scroll", () => {
    if ($scrollSyncToggle.checked) syncScroll($originalPane, $editPane);
  });
  $editPane.addEventListener("scroll", () => {
    if ($scrollSyncToggle.checked) syncScroll($editPane, $originalPane);
  });
}

// ── Cut / Restore ──
function cutBlock(id) {
  const b = blocks.find(x => x.id === id);
  if (!b || b.deleted) return;
  b.deleted = true;
  undoStack.push({ type: "cut", id: b.id });
  $undoBtn.disabled = false;

  updateEditBlock(id);
  updateOriginalBlock(id);
  updateSummary();
}

function restoreBlock(id) {
  const b = blocks.find(x => x.id === id);
  if (!b || !b.deleted) return;
  b.deleted = false;

  updateEditBlock(id);
  updateOriginalBlock(id);
  updateSummary();
}

function undoLast() {
  if (!undoStack.length) return;
  const action = undoStack.pop();
  $undoBtn.disabled = undoStack.length === 0;

  if (action.type === "cut") {
    restoreBlock(action.id);
  } else if (action.type === "edit") {
    const b = blocks.find(x => x.id === action.id);
    if (b) {
      b.text = action.prevText;
      updateEditBlock(action.id);
      updateOriginalBlock(action.id);
      updateSummary();
    }
  }
}

// ── Summary ──
function updateSummary() {
  const total = blocks.length;
  const removed = blocks.filter(b => b.deleted).length;
  const edited = blocks.filter(b => !b.deleted && b.text !== b.originalText).length;
  const cutDuration = blocks.filter(b => b.deleted).reduce((s, b) => s + (b.end - b.start), 0);
  const totalDuration = blocks.length ? blocks[blocks.length - 1].end : 0;
  const pct = totalDuration > 0 ? ((cutDuration / totalDuration) * 100).toFixed(1) : "0.0";

  document.getElementById("sumTotal").textContent = total;
  document.getElementById("sumRemoved").textContent = removed + (edited > 0 ? ` (+${edited} edited)` : "");
  document.getElementById("sumTimeCut").textContent = fmt(cutDuration);
  document.getElementById("sumReduction").textContent = pct + "%";
}

// ── Video sync ──
$videoPlayer.addEventListener("timeupdate", () => {
  if (!$syncToggle.checked) return;
  const t = $videoPlayer.currentTime;
  let active = -1;
  for (const b of blocks) {
    if (t >= b.start && t < b.end) { active = b.id; break; }
  }
  if (active === currentHighlight) return;
  currentHighlight = active;

  // Highlight in both panes
  [$originalPane, $editPane].forEach($pane => {
    $pane.querySelectorAll(".block-card.active").forEach(c => c.classList.remove("active"));
    if (active >= 0) {
      const card = $pane.querySelector(`[data-id="${active}"]`);
      if (card) card.classList.add("active");
    }
  });

  // Scroll the edit pane; original will follow via sync
  if (active >= 0 && $scrollSyncToggle.checked) {
    const card = $editPane.querySelector(`[data-id="${active}"]`);
    if (card) {
      const rect = card.getBoundingClientRect();
      const cRect = $editPane.getBoundingClientRect();
      if (rect.top < cRect.top + 40 || rect.bottom > cRect.bottom) {
        card.scrollIntoView({ behavior: "smooth", block: "center" });
      }
    }
  }
});

function seekTo(time) {
  $videoPlayer.currentTime = time;
}

// ── Margin slider ──
$marginSlider.addEventListener("input", () => {
  $marginVal.textContent = parseFloat($marginSlider.value).toFixed(2) + "s";
});

// ── Advanced mode ──
function toggleAdvanced() {
  const panel = document.getElementById("advanced-panel");
  panel.classList.toggle("hidden");
  const btn = document.getElementById("advancedToggle");
  btn.textContent = panel.classList.contains("hidden") ? "Advanced" : "Simple";
}

// ── Settings ──
const SETTINGS_KEY = "papercut-settings";

const SETTINGS_DEFAULTS = {
  whisperModel: "medium",
  language: "en",
  exportFormat: "final-cut-pro",
  margin: "0.10",
  silentSpeed: "",
  soundedSpeed: "",
  videoCodec: "",
  audioCodec: "",
  ffmpegArgs: "",
  editMethod: "",
  syncPlayback: "true",
  syncScroll: "true",
};

function loadSettings() {
  try {
    const saved = JSON.parse(localStorage.getItem(SETTINGS_KEY));
    return { ...SETTINGS_DEFAULTS, ...saved };
  } catch {
    return { ...SETTINGS_DEFAULTS };
  }
}

function applySettings() {
  const s = loadSettings();

  // Populate settings form
  document.getElementById("settWhisperModel").value = s.whisperModel;
  document.getElementById("settLanguage").value = s.language;
  document.getElementById("settExportFormat").value = s.exportFormat;
  document.getElementById("settMargin").value = s.margin;
  document.getElementById("settSilentSpeed").value = s.silentSpeed;
  document.getElementById("settSoundedSpeed").value = s.soundedSpeed;
  document.getElementById("settVideoCodec").value = s.videoCodec;
  document.getElementById("settAudioCodec").value = s.audioCodec;
  document.getElementById("settFfmpegArgs").value = s.ffmpegArgs;
  document.getElementById("settEditMethod").value = s.editMethod;
  document.getElementById("settSyncPlayback").value = s.syncPlayback;
  document.getElementById("settSyncScroll").value = s.syncScroll;

  // Apply to main UI
  document.getElementById("exportFormat").value = s.exportFormat;
  $marginSlider.value = parseFloat(s.margin);
  $marginVal.textContent = parseFloat(s.margin).toFixed(2) + "s";
  document.getElementById("silentSpeed").value = s.silentSpeed;
  document.getElementById("soundedSpeed").value = s.soundedSpeed;
  document.getElementById("videoCodec").value = s.videoCodec;
  document.getElementById("audioCodec").value = s.audioCodec;
  document.getElementById("ffmpegArgs").value = s.ffmpegArgs;
  document.getElementById("editMethod").value = s.editMethod;
  $syncToggle.checked = s.syncPlayback === "true";
  $scrollSyncToggle.checked = s.syncScroll === "true";
}

function saveSettings() {
  const s = {
    whisperModel: document.getElementById("settWhisperModel").value,
    language: document.getElementById("settLanguage").value,
    exportFormat: document.getElementById("settExportFormat").value,
    margin: document.getElementById("settMargin").value,
    silentSpeed: document.getElementById("settSilentSpeed").value.trim(),
    soundedSpeed: document.getElementById("settSoundedSpeed").value.trim(),
    videoCodec: document.getElementById("settVideoCodec").value.trim(),
    audioCodec: document.getElementById("settAudioCodec").value.trim(),
    ffmpegArgs: document.getElementById("settFfmpegArgs").value.trim(),
    editMethod: document.getElementById("settEditMethod").value.trim(),
    syncPlayback: document.getElementById("settSyncPlayback").value,
    syncScroll: document.getElementById("settSyncScroll").value,
  };
  localStorage.setItem(SETTINGS_KEY, JSON.stringify(s));
  applySettings();
  toggleSettings();
}

function resetSettings() {
  localStorage.removeItem(SETTINGS_KEY);
  applySettings();
}

function toggleSettings() {
  document.getElementById("settingsOverlay").classList.toggle("hidden");
}

// Apply saved settings on load
applySettings();

// ── Export ──
function startExport() {
  if (!videoPath) return;

  const $btn = document.getElementById("exportBtn");
  $btn.disabled = true;
  $btn.textContent = "Exporting\u2026";
  $exportResult.classList.add("hidden");

  // Send originalText for diff matching (so user edits don't break cut detection)
  const keptBlocks = blocks.filter(b => !b.deleted).map(b => ({
    index: b.index,
    start: b.start,
    end: b.end,
    text: b.originalText,
  }));

  fetch("/api/diff", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      orig_srt_path: origSrtPath,
      json_path: jsonPath,
      kept_blocks: keptBlocks,
    }),
  })
  .then(r => r.json())
  .then(diffData => {
    if (diffData.error) throw new Error(diffData.error);
    deletedRanges = diffData.deleted_ranges;

    if (diffData.summary) {
      const s = diffData.summary;
      document.getElementById("sumTotal").textContent = s.total_blocks;
      document.getElementById("sumRemoved").textContent = s.removed_blocks;
      document.getElementById("sumTimeCut").textContent = fmt(s.cut_duration);
      document.getElementById("sumReduction").textContent = s.reduction_pct + "%";
    }

    const payload = {
      video_path: videoPath,
      deleted_ranges: deletedRanges,
      margin: parseFloat($marginSlider.value),
      export: document.getElementById("exportFormat").value,
    };

    const silentSpeed = document.getElementById("silentSpeed").value.trim();
    const soundedSpeed = document.getElementById("soundedSpeed").value.trim();
    const videoCodec = document.getElementById("videoCodec").value.trim();
    const audioCodec = document.getElementById("audioCodec").value.trim();
    const ffmpegArgs = document.getElementById("ffmpegArgs").value.trim();
    const editMethod = document.getElementById("editMethod").value.trim();

    if (silentSpeed) payload.silent_speed = silentSpeed;
    if (soundedSpeed) payload.sounded_speed = soundedSpeed;
    if (videoCodec) payload.video_codec = videoCodec;
    if (audioCodec) payload.audio_codec = audioCodec;
    if (ffmpegArgs) payload.ffmpeg_args = ffmpegArgs;
    if (editMethod) payload.edit_method = editMethod;

    return fetch("/api/export", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
  })
  .then(r => r.json())
  .then(result => {
    $exportResult.classList.remove("hidden");
    if (result.success) {
      $exportResult.className = "success";
      $exportResult.textContent = `${result.message}\n\nCommand: ${result.command}`;
      if (result.stdout) $exportResult.textContent += `\n\n${result.stdout}`;
    } else {
      $exportResult.className = "error";
      $exportResult.textContent = `Export failed: ${result.error}\n\nCommand: ${result.command || "N/A"}`;
    }
  })
  .catch(err => {
    $exportResult.classList.remove("hidden");
    $exportResult.className = "error";
    $exportResult.textContent = "Error: " + err.message;
  })
  .finally(() => {
    $btn.disabled = false;
    $btn.textContent = "Export";
  });
}

// ── Theme Toggle ──
function getTheme() {
  return localStorage.getItem("papercut-theme") || "light";
}

function applyTheme(theme) {
  document.documentElement.setAttribute("data-theme", theme);
  document.getElementById("themeToggle").textContent = theme === "dark" ? "\u2600" : "\u263E";
}

function toggleTheme() {
  const next = getTheme() === "dark" ? "light" : "dark";
  localStorage.setItem("papercut-theme", next);
  applyTheme(next);
}

applyTheme(getTheme());

// ── Keyboard shortcuts ──
document.addEventListener("keydown", (e) => {
  if ((e.ctrlKey || e.metaKey) && e.key === "z" && !e.shiftKey) {
    if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA" || e.target.isContentEditable) return;
    e.preventDefault();
    undoLast();
  }
});
</script>
</body>
</html>
